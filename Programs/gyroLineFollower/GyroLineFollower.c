#pragma config(Sensor, S1,     Color1,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     Gyro,           sensorEV3_Gyro)
#pragma config(Motor,  motorA,          LeftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          RightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int forwardsHeading = 0;
int rightBound = 0;

int threshold = 0;
int stopLine = 0;

int avgReflectedLight(unsigned short samples) {

	unsigned int avgLight = 0;

	for(unsigned short i = 0; i < samples; i++) {
		avgLight = avgLight + getColorReflected(Color1);
	}

	avgLight = avgLight / samples;
	return avgLight;
}

bool isInsideLine() {
	int reflected = getColorReflected(Color1);
	if(reflected < threshold && reflected > stopLine) {
		return true;
	}
	else {
		return false;
	}
}

void faceHeading(int heading) {

	while(heading <  getGyroHeading(Gyro)) {
		setMotorSpeed(LeftMotor, -10);
		setMotorSpeed(RightMotor, 10);
	}

}

void seekBounds() {
	//Seek the left side of the line.
	faceHeading(0);
	setMotorSpeed(LeftMotor, -10);
	setMotorSpeed(RightMotor, 10);
	while(avgReflectedLight(5) < threshold || getGyroHeading(Gyro) > forwardsHeading*0.90) {
	}
	setMotorSpeed(LeftMotor, 0);
	setMotorSpeed(RightMotor, 0);
	resetGyro(Gyro);

	//Seek the right side of the line.

	setMotorSpeed(LeftMotor, 10);
	setMotorSpeed(RightMotor, -10);
	delay(500);
	while(avgReflectedLight(5) < threshold) {
		rightBound = getGyroHeading(Gyro);
	}

	forwardsHeading = rightBound/2;
}

void manualCallibColor() {

	unsigned short lightVal = 0;
	unsigned short greyVal = 0;
	unsigned short darkVal = 0;
	displayBigTextLine(0, "Color callib.");
	displayTextLine(3, "Place sensor on light surface.");
	displayTextLine(4, "Press Enter to accept.");
	while(true) {
		// Display the reflected value live to help manual positioning.
		lightVal = getColorReflected(Color1);
		displayBigTextLine(6, "Reflected: %d", lightVal);

		// Press enter to take 10 light sampels then tage the average and break out of the loop.
		if(getButtonPress(buttonEnter) == 1) {
			lightVal = avgReflectedLight(10);
			break;
		}
	}

	delay(1000);

	eraseDisplay();

	displayBigTextLine(0, "Color callib.");
	displayTextLine(3, "Place sensor on grey surface.");
	displayTextLine(4, "Press Enter to accept.");

	while(true) {
		// Display the reflected value live to help manual positioning.
		greyVal = getColorReflected(Color1);
		displayBigTextLine(6, "Reflected: %d", greyVal);

		// Press enter to take 10 light sampels then tage the average and break out of the loop.
		if(getButtonPress(buttonEnter) == 1) {
			greyVal = avgReflectedLight(10);
			break;
		}
	}

	delay(1000);

	displayBigTextLine(0, "Color callib.");
	displayTextLine(3, "Place sensor on dark surface.");
	displayTextLine(4, "Press Enter to accept.");
	while(true) {
		// Display the reflected value live to help manual positioning.
		darkVal = getColorReflected(Color1);
		displayBigTextLine(6, "Reflected: %d", darkVal);

		// Press enter to take 10 light sampels then tage the average and break out of the loop.
		if(getButtonPress(buttonEnter) == 1) {
			darkVal = avgReflectedLight(10);
			break;
		}
	}
		delay(5000);

	threshold = (lightVal + greyVal) / 2;
	stopLine = darkVal;
}

task main()
{
	manualCallibColor();
	resetGyro(Gyro);
	seekBounds();
	faceHeading(forwardsHeading);
	while(true) {

		if(isInsideLine()) {
			setMotorSpeed(LeftMotor, 30);
			setMotorSpeed(RightMotor, 30);
		}
		else {
			seekBounds();
			faceHeading(forwardsHeading);
			eraseDisplay();
			displayBigTextLine(0, "Head: %d", forwardsHeading);
		}


	}


}
